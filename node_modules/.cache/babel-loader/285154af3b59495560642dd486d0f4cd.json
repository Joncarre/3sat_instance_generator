{"ast":null,"code":"/**\r\n * This function create an object from keys, value and then assign to target\r\n *\r\n * @param {Object} obj : the target object to be assigned\r\n * @param {string[]} keys\r\n * @param {string | number} value\r\n *\r\n * @example\r\n * const source = {}\r\n * assignNestedKeys(source, ['palette', 'primary'], 'var(--palette-primary)')\r\n * console.log(source) // { palette: { primary: 'var(--palette-primary)' } }\r\n *\r\n * @example\r\n * const source = { palette: { primary: 'var(--palette-primary)' } }\r\n * assignNestedKeys(source, ['palette', 'secondary'], 'var(--palette-secondary)')\r\n * console.log(source) // { palette: { primary: 'var(--palette-primary)', secondary: 'var(--palette-secondary)' } }\r\n */\nexport const assignNestedKeys = (obj, keys, value) => {\n  let temp = obj;\n  keys.forEach((k, index) => {\n    if (index === keys.length - 1) {\n      if (temp && typeof temp === 'object') {\n        temp[k] = value;\n      }\n    } else if (temp && typeof temp === 'object') {\n      if (!temp[k]) {\n        temp[k] = {};\n      }\n      temp = temp[k];\n    }\n  });\n};\n/**\r\n *\r\n * @param {Object} obj : source object\r\n * @param {Function} callback : a function that will be called when\r\n *                   - the deepest key in source object is reached\r\n *                   - the value of the deepest key is NOT `undefined` | `null`\r\n *\r\n * @example\r\n * walkObjectDeep({ palette: { primary: { main: '#000000' } } }, console.log)\r\n * // ['palette', 'primary', 'main'] '#000000'\r\n */\n\nexport const walkObjectDeep = (obj, callback, shouldSkipPaths) => {\n  function recurse(object) {\n    let parentKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    Object.entries(object).forEach(_ref => {\n      let [key, value] = _ref;\n      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {\n        if (value !== undefined && value !== null) {\n          if (typeof value === 'object' && Object.keys(value).length > 0) {\n            recurse(value, [...parentKeys, key]);\n          } else {\n            callback([...parentKeys, key], value, object);\n          }\n        }\n      }\n    });\n  }\n  recurse(obj);\n};\nconst getCssValue = (keys, value) => {\n  if (typeof value === 'number') {\n    if (['lineHeight', 'fontWeight', 'opacity', 'zIndex'].some(prop => keys.includes(prop))) {\n      // CSS property that are unitless\n      return value;\n    }\n    return `${value}px`;\n  }\n  return value;\n};\n/**\r\n * a function that parse theme and return { css, vars }\r\n *\r\n * @param {Object} theme\r\n * @param {{\r\n *  prefix?: string,\r\n *  basePrefix?: string,\r\n *  shouldSkipGeneratingVar?: (objectPathKeys: Array<string>, value: string | number) => boolean\r\n * }} options.\r\n *  `basePrefix`: defined by design system.\r\n *  `prefix`: defined by application\r\n *\r\n *   This function also mutate the string value of theme input by replacing `basePrefix` (if existed) with `prefix`\r\n *\r\n * @returns {{ css: Object, vars: Object }} `css` is the stylesheet, `vars` is an object to get css variable (same structure as theme)\r\n *\r\n * @example\r\n * const { css, vars } = parser({\r\n *   fontSize: 12,\r\n *   lineHeight: 1.2,\r\n *   palette: { primary: { 500: '#000000' } }\r\n * })\r\n *\r\n * console.log(css) // { '--fontSize': '12px', '--lineHeight': 1.2, '--palette-primary-500': '#000000' }\r\n * console.log(vars) // { fontSize: '--fontSize', lineHeight: '--lineHeight', palette: { primary: { 500: 'var(--palette-primary-500)' } } }\r\n */\n\nexport default function cssVarsParser(theme, options) {\n  const {\n    prefix,\n    basePrefix = '',\n    shouldSkipGeneratingVar\n  } = options || {};\n  const css = {};\n  const vars = {};\n  walkObjectDeep(theme, (keys, val, scope) => {\n    if (typeof val === 'string' || typeof val === 'number') {\n      let value = val;\n      if (typeof value === 'string' && value.startsWith('var')) {\n        // replace the value of the `scope` object with the prefix or remove basePrefix from the value\n        if (!basePrefix && prefix) {\n          value = value.replace(/var\\(--/g, `var(--${prefix}-`);\n        } else {\n          value = prefix ? value.replace(new RegExp(basePrefix, 'g'), prefix) : value.replace(new RegExp(`${basePrefix}-`, 'g'), '');\n        } // scope is the deepest object in the tree, keys is the theme path keys\n\n        scope[keys.slice(-1)[0]] = value;\n      }\n      if (!shouldSkipGeneratingVar || shouldSkipGeneratingVar && !shouldSkipGeneratingVar(keys, value)) {\n        // only create css & var if `shouldSkipGeneratingVar` return false\n        const cssVar = `--${prefix ? `${prefix}-` : ''}${keys.join('-')}`;\n        Object.assign(css, {\n          [cssVar]: getCssValue(keys, value)\n        });\n        assignNestedKeys(vars, keys, `var(${cssVar})`);\n      }\n    }\n  }, keys => keys[0] === 'vars' // skip 'vars/*' paths\n  );\n\n  return {\n    css,\n    vars\n  };\n}","map":{"version":3,"names":["assignNestedKeys","obj","keys","value","temp","forEach","k","index","length","walkObjectDeep","callback","shouldSkipPaths","recurse","object","parentKeys","Object","entries","key","undefined","getCssValue","some","prop","includes","cssVarsParser","theme","options","prefix","basePrefix","shouldSkipGeneratingVar","css","vars","val","scope","startsWith","replace","RegExp","slice","cssVar","join","assign"],"sources":["C:/Users/Jona_/Documents/GitHub/3sat_instance_generator/node_modules/@mui/system/esm/cssVars/cssVarsParser.js"],"sourcesContent":["/**\r\n * This function create an object from keys, value and then assign to target\r\n *\r\n * @param {Object} obj : the target object to be assigned\r\n * @param {string[]} keys\r\n * @param {string | number} value\r\n *\r\n * @example\r\n * const source = {}\r\n * assignNestedKeys(source, ['palette', 'primary'], 'var(--palette-primary)')\r\n * console.log(source) // { palette: { primary: 'var(--palette-primary)' } }\r\n *\r\n * @example\r\n * const source = { palette: { primary: 'var(--palette-primary)' } }\r\n * assignNestedKeys(source, ['palette', 'secondary'], 'var(--palette-secondary)')\r\n * console.log(source) // { palette: { primary: 'var(--palette-primary)', secondary: 'var(--palette-secondary)' } }\r\n */\r\nexport const assignNestedKeys = (obj, keys, value) => {\r\n  let temp = obj;\r\n  keys.forEach((k, index) => {\r\n    if (index === keys.length - 1) {\r\n      if (temp && typeof temp === 'object') {\r\n        temp[k] = value;\r\n      }\r\n    } else if (temp && typeof temp === 'object') {\r\n      if (!temp[k]) {\r\n        temp[k] = {};\r\n      }\r\n\r\n      temp = temp[k];\r\n    }\r\n  });\r\n};\r\n/**\r\n *\r\n * @param {Object} obj : source object\r\n * @param {Function} callback : a function that will be called when\r\n *                   - the deepest key in source object is reached\r\n *                   - the value of the deepest key is NOT `undefined` | `null`\r\n *\r\n * @example\r\n * walkObjectDeep({ palette: { primary: { main: '#000000' } } }, console.log)\r\n * // ['palette', 'primary', 'main'] '#000000'\r\n */\r\n\r\nexport const walkObjectDeep = (obj, callback, shouldSkipPaths) => {\r\n  function recurse(object, parentKeys = []) {\r\n    Object.entries(object).forEach(([key, value]) => {\r\n      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {\r\n        if (value !== undefined && value !== null) {\r\n          if (typeof value === 'object' && Object.keys(value).length > 0) {\r\n            recurse(value, [...parentKeys, key]);\r\n          } else {\r\n            callback([...parentKeys, key], value, object);\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  recurse(obj);\r\n};\r\n\r\nconst getCssValue = (keys, value) => {\r\n  if (typeof value === 'number') {\r\n    if (['lineHeight', 'fontWeight', 'opacity', 'zIndex'].some(prop => keys.includes(prop))) {\r\n      // CSS property that are unitless\r\n      return value;\r\n    }\r\n\r\n    return `${value}px`;\r\n  }\r\n\r\n  return value;\r\n};\r\n/**\r\n * a function that parse theme and return { css, vars }\r\n *\r\n * @param {Object} theme\r\n * @param {{\r\n *  prefix?: string,\r\n *  basePrefix?: string,\r\n *  shouldSkipGeneratingVar?: (objectPathKeys: Array<string>, value: string | number) => boolean\r\n * }} options.\r\n *  `basePrefix`: defined by design system.\r\n *  `prefix`: defined by application\r\n *\r\n *   This function also mutate the string value of theme input by replacing `basePrefix` (if existed) with `prefix`\r\n *\r\n * @returns {{ css: Object, vars: Object }} `css` is the stylesheet, `vars` is an object to get css variable (same structure as theme)\r\n *\r\n * @example\r\n * const { css, vars } = parser({\r\n *   fontSize: 12,\r\n *   lineHeight: 1.2,\r\n *   palette: { primary: { 500: '#000000' } }\r\n * })\r\n *\r\n * console.log(css) // { '--fontSize': '12px', '--lineHeight': 1.2, '--palette-primary-500': '#000000' }\r\n * console.log(vars) // { fontSize: '--fontSize', lineHeight: '--lineHeight', palette: { primary: { 500: 'var(--palette-primary-500)' } } }\r\n */\r\n\r\n\r\nexport default function cssVarsParser(theme, options) {\r\n  const {\r\n    prefix,\r\n    basePrefix = '',\r\n    shouldSkipGeneratingVar\r\n  } = options || {};\r\n  const css = {};\r\n  const vars = {};\r\n  walkObjectDeep(theme, (keys, val, scope) => {\r\n    if (typeof val === 'string' || typeof val === 'number') {\r\n      let value = val;\r\n\r\n      if (typeof value === 'string' && value.startsWith('var')) {\r\n        // replace the value of the `scope` object with the prefix or remove basePrefix from the value\r\n        if (!basePrefix && prefix) {\r\n          value = value.replace(/var\\(--/g, `var(--${prefix}-`);\r\n        } else {\r\n          value = prefix ? value.replace(new RegExp(basePrefix, 'g'), prefix) : value.replace(new RegExp(`${basePrefix}-`, 'g'), '');\r\n        } // scope is the deepest object in the tree, keys is the theme path keys\r\n\r\n\r\n        scope[keys.slice(-1)[0]] = value;\r\n      }\r\n\r\n      if (!shouldSkipGeneratingVar || shouldSkipGeneratingVar && !shouldSkipGeneratingVar(keys, value)) {\r\n        // only create css & var if `shouldSkipGeneratingVar` return false\r\n        const cssVar = `--${prefix ? `${prefix}-` : ''}${keys.join('-')}`;\r\n        Object.assign(css, {\r\n          [cssVar]: getCssValue(keys, value)\r\n        });\r\n        assignNestedKeys(vars, keys, `var(${cssVar})`);\r\n      }\r\n    }\r\n  }, keys => keys[0] === 'vars' // skip 'vars/*' paths\r\n  );\r\n  return {\r\n    css,\r\n    vars\r\n  };\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}